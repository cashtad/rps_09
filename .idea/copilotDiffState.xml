<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/main/java/com/rps/network/ProtocolHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/main/java/com/rps/network/ProtocolHandler.java" />
              <option name="originalContent" value="package com.rps.network;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class ProtocolHandler {&#10;    private final NetworkManager net;&#10;    private final EventBus eventBus;&#10;    private String token;&#10;&#10;    // Временные данные для сбора списка комнат&#10;    private final List&lt;String&gt; tempRooms = new ArrayList&lt;&gt;();&#10;    private int expectedRooms = 0;&#10;&#10;    public ProtocolHandler(NetworkManager net, EventBus eventBus) {&#10;        this.net = net;&#10;        this.eventBus = eventBus;&#10;        this.net.setOnMessageReceived(this::handleMessage);&#10;        setupInternalHandlers();&#10;    }&#10;&#10;    private void setupInternalHandlers() {&#10;        // Обработка ROOM_LIST - начало сбора комнат&#10;        eventBus.subscribe(&quot;ROOM_LIST&quot;, event -&gt; {&#10;            expectedRooms = Integer.parseInt(event.getPart(1));&#10;            tempRooms.clear();&#10;&#10;            // Если комнат 0, сразу публикуем событие с пустым списком&#10;            if (expectedRooms == 0) {&#10;                eventBus.publish(new ServerEvent(&quot;ROOMS_LOADED&quot;,&#10;                        new String[]{&quot;ROOMS_LOADED&quot;}, &quot;ROOMS_LOADED&quot;));&#10;            }&#10;        });&#10;&#10;        // Обработка ROOM - добавление комнаты в список&#10;        eventBus.subscribe(&quot;ROOM&quot;, event -&gt; {&#10;            tempRooms.add(event.getFullMessage().substring(5));&#10;&#10;            // Когда собрали все комнаты, публикуем событие&#10;            if (tempRooms.size() == expectedRooms) {&#10;                // Создаем специальное событие с полным списком комнат&#10;                String roomsData = String.join(&quot;|&quot;, tempRooms);&#10;                eventBus.publish(new ServerEvent(&quot;ROOMS_LOADED&quot;,&#10;                        new String[]{&quot;ROOMS_LOADED&quot;, roomsData}, roomsData));&#10;            }&#10;        });&#10;&#10;        // Обработка ROOM_CREATED - автоматический запрос списка комнат&#10;        eventBus.subscribe(&quot;ROOM_CREATED&quot;, event -&gt; {&#10;            requestRooms();&#10;        });&#10;    }&#10;&#10;    private void handleMessage(String msg) {&#10;        System.out.println(&quot;SERVER: &quot; + msg);&#10;&#10;        String[] parts = msg.split(&quot; &quot;, 2); // Разделяем только на команду и остальное&#10;        String command = parts[0];&#10;&#10;        // Парсим для детального доступа&#10;        String[] allParts = msg.split(&quot; &quot;);&#10;&#10;        // Создаем событие и публикуем в шину&#10;        ServerEvent event = new ServerEvent(command, allParts, msg);&#10;        eventBus.publish(event);&#10;&#10;        // Сохраняем токен при WELCOME&#10;        if (&quot;WELCOME&quot;.equals(command) &amp;&amp; allParts.length &gt; 1) {&#10;            token = allParts[1];&#10;        }&#10;    }&#10;&#10;    // =================== Client Commands ===================&#10;&#10;    public void sendHello(String nickname) {&#10;        net.send(&quot;HELLO &quot; + nickname);&#10;    }&#10;&#10;    public void requestRooms() {&#10;        net.send(&quot;LIST&quot;);&#10;    }&#10;&#10;    public void createRoom(String name) {&#10;        net.send(&quot;CREATE &quot; + name);&#10;    }&#10;&#10;    public void joinRoom(String id) {&#10;        net.send(&quot;JOIN &quot; + id);&#10;    }&#10;&#10;    public void markReady() {&#10;        net.send(&quot;READY&quot;);&#10;    }&#10;&#10;    public void sendMove(String move) {&#10;        net.send(&quot;MOVE &quot; + move);&#10;    }&#10;&#10;    public void leaveRoom() {&#10;        net.send(&quot;LEAVE&quot;);&#10;    }&#10;&#10;    public void requestOpponentInfo() {&#10;        net.send(&quot;GET_OPPONENT&quot;);&#10;    }&#10;&#10;    public String getToken() {&#10;        return token;&#10;    }&#10;&#10;    public EventBus getEventBus() {&#10;        return eventBus;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.rps.network;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;public class ProtocolHandler {&#10;    private final NetworkManager net;&#10;    private final EventBus eventBus;&#10;    private String token;&#10;&#10;    // Временные данные для сбора списка комнат&#10;    private final List&lt;String&gt; tempRooms = new ArrayList&lt;&gt;();&#10;    private int expectedRooms = 0;&#10;&#10;    public ProtocolHandler(NetworkManager net, EventBus eventBus) {&#10;        this.net = net;&#10;        this.eventBus = eventBus;&#10;        this.net.setOnMessageReceived(this::handleMessage);&#10;        setupInternalHandlers();&#10;    }&#10;&#10;    private void setupInternalHandlers() {&#10;        // Обработка ROOM_LIST - начало сбора комнат&#10;        eventBus.subscribe(&quot;ROOM_LIST&quot;, event -&gt; {&#10;            expectedRooms = Integer.parseInt(event.getPart(1));&#10;            tempRooms.clear();&#10;&#10;            // Если комнат 0, сразу публикуем событие с пустым списком&#10;            if (expectedRooms == 0) {&#10;                eventBus.publish(new ServerEvent(&quot;ROOMS_LOADED&quot;,&#10;                        new String[]{&quot;ROOMS_LOADED&quot;}, &quot;ROOMS_LOADED&quot;));&#10;            }&#10;        });&#10;&#10;        // Обработка ROOM - добавление комнаты в список&#10;        eventBus.subscribe(&quot;ROOM&quot;, event -&gt; {&#10;            tempRooms.add(event.getFullMessage().substring(5));&#10;&#10;            // Когда собрали все комнаты, публикуем событие&#10;            if (tempRooms.size() == expectedRooms) {&#10;                // Создаем специальное событие с полным списком комнат&#10;                String roomsData = String.join(&quot;|&quot;, tempRooms);&#10;                eventBus.publish(new ServerEvent(&quot;ROOMS_LOADED&quot;,&#10;                        new String[]{&quot;ROOMS_LOADED&quot;, roomsData}, roomsData));&#10;            }&#10;        });&#10;&#10;        // Обработка ROOM_CREATED - автоматический запрос списка комнат&#10;        eventBus.subscribe(&quot;ROOM_CREATED&quot;, event -&gt; {&#10;            requestRooms();&#10;        });&#10;    }&#10;&#10;    private void handleMessage(String msg) {&#10;        System.out.println(&quot;SERVER: &quot; + msg);&#10;&#10;        String[] parts = msg.split(&quot; &quot;, 2); // Разделяем только на команду и остальное&#10;        String command = parts[0];&#10;&#10;        // Парсим для детального доступа&#10;        String[] allParts = msg.split(&quot; &quot;);&#10;&#10;        // Создаем событие и публикуем в шину&#10;        ServerEvent event = new ServerEvent(command, allParts, msg);&#10;        eventBus.publish(event);&#10;&#10;        // Сохраняем токен при WELCOME&#10;        if (&quot;WELCOME&quot;.equals(command) &amp;&amp; allParts.length &gt; 1) {&#10;            token = allParts[1];&#10;        }&#10;    }&#10;&#10;    // =================== Client Commands ===================&#10;&#10;    public void sendHello(String nickname) {&#10;        net.send(&quot;HELLO &quot; + nickname);&#10;    }&#10;&#10;    public void requestRooms() {&#10;        net.send(&quot;LIST&quot;);&#10;    }&#10;&#10;    public void createRoom(String name) {&#10;        net.send(&quot;CREATE &quot; + name);&#10;    }&#10;&#10;    public void joinRoom(String id) {&#10;        net.send(&quot;JOIN &quot; + id);&#10;    }&#10;&#10;    public void markReady() {&#10;        net.send(&quot;READY&quot;);&#10;    }&#10;&#10;    public void sendMove(String move) {&#10;        net.send(&quot;MOVE &quot; + move);&#10;    }&#10;&#10;    public void leaveRoom() {&#10;        net.send(&quot;LEAVE&quot;);&#10;    }&#10;&#10;    public void requestOpponentInfo() {&#10;        net.send(&quot;GET_OPPONENT&quot;);&#10;    }&#10;&#10;    public String getToken() {&#10;        return token;&#10;    }&#10;&#10;    public EventBus getEventBus() {&#10;        return eventBus;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/include/client.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/include/client.h" />
              <option name="originalContent" value="#ifndef RPS_09_CLIENT_H&#10;#define RPS_09_CLIENT_H&#10;&#10;#include &quot;server.h&quot;&#10;&#10;// Client management functions&#10;int register_client(client_t *c);&#10;void unregister_client(const client_t *c);&#10;client_t* find_client_by_fd(int fd);&#10;void gen_token(char *out);&#10;&#10;#endif //RPS_09_CLIENT_H&#10;" />
              <option name="updatedContent" value="#ifndef RPS_09_CLIENT_H&#10;#define RPS_09_CLIENT_H&#10;&#10;#include &quot;server.h&quot;&#10;&#10;// Client management functions&#10;int register_client(client_t *c);&#10;void unregister_client(const client_t *c);&#10;client_t* find_client_by_fd(int fd);&#10;void gen_token(char *out);&#10;&#10;#endif //RPS_09_CLIENT_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/include/commands.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/include/commands.h" />
              <option name="originalContent" value="#ifndef RPS_09_COMMANDS_H&#10;#define RPS_09_COMMANDS_H&#10;&#10;#include &quot;server.h&quot;&#10;#include &quot;game.h&quot;&#10;&#10;// Command handlers&#10;void handle_line(client_t *c, char *line);&#10;void handle_hello(client_t *c, char *args);&#10;void handle_list(const client_t *c);&#10;void handle_create(client_t *c, char *args);&#10;void handle_join(client_t *c, char *args);&#10;void handle_ready(client_t *c);&#10;void handle_leave(client_t *c);&#10;void handle_move(client_t *c, char *args);&#10;void handle_get_opponent(client_t *c);&#10;void handle_quit(client_t *c);&#10;&#10;#endif //RPS_09_COMMANDS_H&#10;" />
              <option name="updatedContent" value="#ifndef RPS_09_COMMANDS_H&#10;#define RPS_09_COMMANDS_H&#10;&#10;#include &quot;server.h&quot;&#10;#include &quot;game.h&quot;&#10;&#10;// Command handlers&#10;void handle_line(client_t *c, char *line);&#10;void handle_hello(client_t *c, char *args);&#10;void handle_list(const client_t *c);&#10;void handle_create(client_t *c, char *args);&#10;void handle_join(client_t *c, char *args);&#10;void handle_ready(client_t *c);&#10;void handle_leave(client_t *c);&#10;void handle_move(client_t *c, char *args);&#10;void handle_get_opponent(client_t *c);&#10;void handle_quit(client_t *c);&#10;&#10;#endif //RPS_09_COMMANDS_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/src/commands.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/src/commands.c" />
              <option name="originalContent" value="#include &quot;../include/commands.h&quot;&#10;#include &quot;../include/network.h&quot;&#10;#include &quot;../include/room.h&quot;&#10;#include &quot;../include/client.h&quot;&#10;#include &lt;string.h&gt;&#10;#include &lt;pthread.h&gt;&#10;&#10;extern pthread_mutex_t global_lock;&#10;&#10;void handle_hello(client_t *c, char *args) {&#10;    char *nick = strtok(args, &quot; &quot;);&#10;    if (!nick) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_nick&quot;);&#10;        return;&#10;    }&#10;    strncpy(c-&gt;nick, nick, NICK_MAX);&#10;    c-&gt;nick[NICK_MAX] = '\0';&#10;    gen_token(c-&gt;token);&#10;    c-&gt;state = ST_AUTH;&#10;    send_line(c-&gt;fd, &quot;WELCOME %s&quot;, c-&gt;token);&#10;}&#10;&#10;void handle_list(const client_t *c) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_auth&quot;);&#10;        return;&#10;    }&#10;    send_room_list(c-&gt;fd);&#10;}&#10;&#10;void handle_create(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *rname = strtok(args, &quot; &quot;);&#10;    if (!rname) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_name&quot;);&#10;        return;&#10;    }&#10;    int rid = create_room(rname);&#10;    if (rid &lt; 0) {&#10;        send_line(c-&gt;fd, &quot;ERR 200 SERVER_FULL&quot;);&#10;        return;&#10;    }&#10;    char buf[LINE_BUF];&#10;    snprintf(buf, LINE_BUF, &quot;ROOM_CREATED %d&quot;, rid);&#10;    send_broadcast(buf);&#10;}&#10;&#10;void handle_join(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *idstr = strtok(args, &quot; &quot;);&#10;    if (!idstr) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_id&quot;);&#10;        return;&#10;    }&#10;    int rid = atoi(idstr);&#10;&#10;    room_t *r = find_room_by_id(rid);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 106 ROOM_WRONG_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    add_player_to_room(c, r);&#10;&#10;    if (r-&gt;player_count == 2) {&#10;        client_t *other = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;        send_line(other-&gt;fd, &quot;PLAYER_JOINED %s&quot;, c-&gt;nick);&#10;        send_line(c-&gt;fd, &quot;PLAYER_JOINED %s&quot;, other-&gt;nick);&#10;    }&#10;}&#10;&#10;void handle_ready(client_t *c) {&#10;    c-&gt;state = ST_READY;&#10;    send_line(c-&gt;fd, &quot;OK you_are_ready&quot;);&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || r-&gt;player_count == 1) return;&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;&#10;    send_line(opponent-&gt;fd, &quot;PLAYER_READY %s&quot;, c-&gt;nick);&#10;&#10;    if (opponent-&gt;state == ST_READY) {&#10;        // Оба игрока готовы, начинаем игру&#10;        send_line(r-&gt;player1-&gt;fd, &quot;GAME_START&quot;);&#10;        send_line(r-&gt;player2-&gt;fd, &quot;GAME_START&quot;);&#10;        c-&gt;state = ST_PLAYING;&#10;        opponent-&gt;state = ST_PLAYING;&#10;        r-&gt;state = RM_PLAYING;&#10;&#10;        // Инициализируем игру&#10;        r-&gt;round_number = 0;&#10;        r-&gt;score_p1 = 0;&#10;        r-&gt;score_p2 = 0;&#10;&#10;        start_next_round(r);  // запускаем первый раунд&#10;    }&#10;}&#10;&#10;void handle_leave(client_t *c) {&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_FULL &amp;&amp; r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    remove_player_from_room(c, r);&#10;    send_line(c-&gt;fd, &quot;LEFT_ROOM %d&quot;, r-&gt;id);&#10;}&#10;&#10;void handle_move(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_PLAYING) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || !r-&gt;awaiting_moves) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_accepting_moves&quot;);&#10;        return;&#10;    }&#10;&#10;    char *move = strtok(args, &quot; &quot;);&#10;    if (!move || (move[0] != 'R' &amp;&amp; move[0] != 'P' &amp;&amp; move[0] != 'S')) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT invalid_move&quot;);&#10;        return;&#10;    }&#10;&#10;    // Сохраняем ход&#10;    if (r-&gt;player1 == c) {&#10;        if (r-&gt;move_p1 != '\0') {&#10;            send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE move_already_sent&quot;);&#10;            return;&#10;        }&#10;        r-&gt;move_p1 = move[0];&#10;    } else {&#10;        if (r-&gt;move_p2 != '\0') {&#10;            send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE move_already_sent&quot;);&#10;            return;&#10;        }&#10;        r-&gt;move_p2 = move[0];&#10;    }&#10;&#10;    send_line(c-&gt;fd, &quot;MOVE_ACCEPTED&quot;);&#10;&#10;    // Проверяем, получены ли оба хода&#10;    if (r-&gt;move_p1 != '\0' &amp;&amp; r-&gt;move_p2 != '\0') {&#10;        r-&gt;awaiting_moves = 0;&#10;        process_round_result(r);&#10;    }&#10;}&#10;&#10;void handle_get_opponent(client_t *c) {&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_in_lobby&quot;);&#10;        return;&#10;    }&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;player_count == 1) {&#10;        send_line(c-&gt;fd, &quot;OPPONENT_INFO NONE&quot;);&#10;        return;&#10;    }&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;    const char *status = (opponent-&gt;state == ST_READY) ? &quot;READY&quot; : &quot;NOT_READY&quot;;&#10;    send_line(c-&gt;fd, &quot;OPPONENT_INFO %s %s&quot;, opponent-&gt;nick, status);&#10;}&#10;&#10;void handle_line(client_t *c, char *line) {&#10;    trim_crlf(line);&#10;    if (strlen(line) == 0) return;&#10;&#10;    char *cmd = strtok(line, &quot; &quot;);&#10;    if (!cmd) return;&#10;&#10;    char *args = strtok(NULL, &quot;&quot;);&#10;&#10;    if (strcmp(cmd, &quot;HELLO&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_hello(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LIST&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_list(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;CREATE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_create(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;JOIN&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_join(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;READY&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_ready(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LEAVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_leave(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;MOVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_move(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;GET_OPPONENT&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_get_opponent(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;OK bye&quot;);&#10;    } else if (strcmp(cmd, &quot;PING&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;PONG&quot;);&#10;    } else {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT unknown_command&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/commands.h&quot;&#10;#include &quot;../include/network.h&quot;&#10;#include &quot;../include/room.h&quot;&#10;#include &quot;../include/client.h&quot;&#10;#include &lt;string.h&gt;&#10;#include &lt;pthread.h&gt;&#10;&#10;extern pthread_mutex_t global_lock;&#10;&#10;void handle_hello(client_t *c, char *args) {&#10;    char *nick = strtok(args, &quot; &quot;);&#10;    if (!nick) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_nick&quot;);&#10;        return;&#10;    }&#10;    strncpy(c-&gt;nick, nick, NICK_MAX);&#10;    c-&gt;nick[NICK_MAX] = '\0';&#10;    gen_token(c-&gt;token);&#10;    c-&gt;state = ST_AUTH;&#10;    send_line(c-&gt;fd, &quot;WELCOME %s&quot;, c-&gt;token);&#10;}&#10;&#10;void handle_list(const client_t *c) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_auth&quot;);&#10;        return;&#10;    }&#10;    send_room_list(c-&gt;fd);&#10;}&#10;&#10;void handle_create(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *rname = strtok(args, &quot; &quot;);&#10;    if (!rname) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_name&quot;);&#10;        return;&#10;    }&#10;    int rid = create_room(rname);&#10;    if (rid &lt; 0) {&#10;        send_line(c-&gt;fd, &quot;ERR 200 SERVER_FULL&quot;);&#10;        return;&#10;    }&#10;    char buf[LINE_BUF];&#10;    snprintf(buf, LINE_BUF, &quot;ROOM_CREATED %d&quot;, rid);&#10;    send_broadcast(buf);&#10;}&#10;&#10;void handle_join(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *idstr = strtok(args, &quot; &quot;);&#10;    if (!idstr) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_id&quot;);&#10;        return;&#10;    }&#10;    int rid = atoi(idstr);&#10;&#10;    room_t *r = find_room_by_id(rid);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 106 ROOM_WRONG_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    add_player_to_room(c, r);&#10;&#10;    if (r-&gt;player_count == 2) {&#10;        client_t *other = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;        send_line(other-&gt;fd, &quot;PLAYER_JOINED %s&quot;, c-&gt;nick);&#10;        send_line(c-&gt;fd, &quot;PLAYER_JOINED %s&quot;, other-&gt;nick);&#10;    }&#10;}&#10;&#10;void handle_ready(client_t *c) {&#10;    c-&gt;state = ST_READY;&#10;    send_line(c-&gt;fd, &quot;OK you_are_ready&quot;);&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || r-&gt;player_count == 1) return;&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;&#10;    send_line(opponent-&gt;fd, &quot;PLAYER_READY %s&quot;, c-&gt;nick);&#10;&#10;    if (opponent-&gt;state == ST_READY) {&#10;        // Оба игрока готовы, начинаем игру&#10;        send_line(r-&gt;player1-&gt;fd, &quot;GAME_START&quot;);&#10;        send_line(r-&gt;player2-&gt;fd, &quot;GAME_START&quot;);&#10;        c-&gt;state = ST_PLAYING;&#10;        opponent-&gt;state = ST_PLAYING;&#10;        r-&gt;state = RM_PLAYING;&#10;&#10;        // Инициализируем игру&#10;        r-&gt;round_number = 0;&#10;        r-&gt;score_p1 = 0;&#10;        r-&gt;score_p2 = 0;&#10;&#10;        start_next_round(r);  // запускаем первый раунд&#10;    }&#10;}&#10;&#10;void handle_leave(client_t *c) {&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_FULL &amp;&amp; r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    remove_player_from_room(c, r);&#10;    send_line(c-&gt;fd, &quot;LEFT_ROOM %d&quot;, r-&gt;id);&#10;}&#10;&#10;void handle_move(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_PLAYING) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || !r-&gt;awaiting_moves) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_accepting_moves&quot;);&#10;        return;&#10;    }&#10;&#10;    char *move = strtok(args, &quot; &quot;);&#10;    if (!move || (move[0] != 'R' &amp;&amp; move[0] != 'P' &amp;&amp; move[0] != 'S')) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT invalid_move&quot;);&#10;        return;&#10;    }&#10;&#10;    // Сохраняем ход&#10;    if (r-&gt;player1 == c) {&#10;        if (r-&gt;move_p1 != '\0') {&#10;            send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE move_already_sent&quot;);&#10;            return;&#10;        }&#10;        r-&gt;move_p1 = move[0];&#10;    } else {&#10;        if (r-&gt;move_p2 != '\0') {&#10;            send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE move_already_sent&quot;);&#10;            return;&#10;        }&#10;        r-&gt;move_p2 = move[0];&#10;    }&#10;&#10;    send_line(c-&gt;fd, &quot;MOVE_ACCEPTED&quot;);&#10;&#10;    // Проверяем, получены ли оба хода&#10;    if (r-&gt;move_p1 != '\0' &amp;&amp; r-&gt;move_p2 != '\0') {&#10;        r-&gt;awaiting_moves = 0;&#10;        process_round_result(r);&#10;    }&#10;}&#10;&#10;void handle_get_opponent(client_t *c) {&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_in_lobby&quot;);&#10;        return;&#10;    }&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;player_count == 1) {&#10;        send_line(c-&gt;fd, &quot;OPPONENT_INFO NONE&quot;);&#10;        return;&#10;    }&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;    const char *status = (opponent-&gt;state == ST_READY) ? &quot;READY&quot; : &quot;NOT_READY&quot;;&#10;    send_line(c-&gt;fd, &quot;OPPONENT_INFO %s %s&quot;, opponent-&gt;nick, status);&#10;}&#10;&#10;void handle_line(client_t *c, char *line) {&#10;    trim_crlf(line);&#10;    if (strlen(line) == 0) return;&#10;&#10;    char *cmd = strtok(line, &quot; &quot;);&#10;    if (!cmd) return;&#10;&#10;    char *args = strtok(NULL, &quot;&quot;);&#10;&#10;    if (strcmp(cmd, &quot;HELLO&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_hello(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LIST&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_list(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;CREATE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_create(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;JOIN&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_join(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;READY&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_ready(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LEAVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_leave(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;MOVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_move(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;GET_OPPONENT&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_get_opponent(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;OK bye&quot;);&#10;    } else if (strcmp(cmd, &quot;PING&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;PONG&quot;);&#10;    } else {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT unknown_command&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>