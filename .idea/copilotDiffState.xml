<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/server/include/client.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/include/client.h" />
              <option name="originalContent" value="#ifndef RPS_09_CLIENT_H&#10;#define RPS_09_CLIENT_H&#10;&#10;#include &quot;server.h&quot;&#10;&#10;// Client management functions&#10;int register_client(client_t *c);&#10;void unregister_client(const client_t *c);&#10;client_t* find_client_by_fd(int fd);&#10;void gen_token(char *out);&#10;&#10;#endif //RPS_09_CLIENT_H&#10;" />
              <option name="updatedContent" value="#ifndef RPS_09_CLIENT_H&#10;#define RPS_09_CLIENT_H&#10;&#10;#include &quot;server.h&quot;&#10;&#10;// Client management functions&#10;int register_client(client_t *c);&#10;void unregister_client(const client_t *c);&#10;client_t* find_client_by_fd(int fd);&#10;void gen_token(char *out);&#10;&#10;#endif //RPS_09_CLIENT_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/src/commands.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/src/commands.c" />
              <option name="originalContent" value="#include &quot;../include/commands.h&quot;&#10;#include &quot;../include/network.h&quot;&#10;#include &quot;../include/room.h&quot;&#10;#include &quot;../include/client.h&quot;&#10;#include &lt;string.h&gt;&#10;#include &lt;pthread.h&gt;&#10;&#10;extern pthread_mutex_t global_lock;&#10;&#10;void handle_hello(client_t *c, char *args) {&#10;    char *nick = strtok(args, &quot; &quot;);&#10;    if (!nick) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_nick&quot;);&#10;        return;&#10;    }&#10;    strncpy(c-&gt;nick, nick, NICK_MAX);&#10;    c-&gt;nick[NICK_MAX] = '\0';&#10;    gen_token(c-&gt;token);&#10;    c-&gt;state = ST_AUTH;&#10;    send_line(c-&gt;fd, &quot;WELCOME %s&quot;, c-&gt;token);&#10;}&#10;&#10;void handle_list(client_t *c) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_auth&quot;);&#10;        return;&#10;    }&#10;    send_room_list(c-&gt;fd);&#10;}&#10;&#10;void handle_create(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *rname = strtok(args, &quot; &quot;);&#10;    if (!rname) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_name&quot;);&#10;        return;&#10;    }&#10;    int rid = create_room(rname);&#10;    if (rid &lt; 0) {&#10;        send_line(c-&gt;fd, &quot;ERR 200 SERVER_FULL&quot;);&#10;        return;&#10;    }&#10;    char buf[LINE_BUF];&#10;    snprintf(buf, LINE_BUF, &quot;ROOM_CREATED %d&quot;, rid);&#10;    send_broadcast(buf);&#10;}&#10;&#10;void handle_join(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *idstr = strtok(args, &quot; &quot;);&#10;    if (!idstr) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_id&quot;);&#10;        return;&#10;    }&#10;    int rid = atoi(idstr);&#10;&#10;    room_t *r = find_room_by_id(rid);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 106 ROOM_WRONG_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    add_player_to_room(c, r);&#10;&#10;    if (r-&gt;player_count == 2) {&#10;        client_t *other = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;        send_line(other-&gt;fd, &quot;PLAYER_JOINED %s&quot;, c-&gt;nick);&#10;    }&#10;}&#10;&#10;void handle_ready(client_t *c) {&#10;    c-&gt;state = ST_READY;&#10;    send_line(c-&gt;fd, &quot;OK you_are_ready&quot;);&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || r-&gt;player_count == 1) return;&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;&#10;    if (opponent-&gt;state == ST_READY) {&#10;        r-&gt;state = RM_PLAYING;&#10;    }&#10;    send_line(opponent-&gt;fd, &quot;PLAYER_READY %s&quot;, c-&gt;nick);&#10;}&#10;&#10;void handle_leave(client_t *c) {&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_FULL &amp;&amp; r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    remove_player_from_room(c, r);&#10;    send_line(c-&gt;fd, &quot;LEFT_ROOM %d&quot;, r-&gt;id);&#10;}&#10;&#10;void handle_line(client_t *c, char *line) {&#10;    trim_crlf(line);&#10;    if (strlen(line) == 0) return;&#10;&#10;    char *cmd = strtok(line, &quot; &quot;);&#10;    if (!cmd) return;&#10;&#10;    char *args = strtok(NULL, &quot;&quot;);&#10;&#10;    if (strcmp(cmd, &quot;HELLO&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_hello(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LIST&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_list(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;CREATE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_create(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;JOIN&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_join(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;READY&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_ready(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LEAVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_leave(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;OK bye&quot;);&#10;    } else if (strcmp(cmd, &quot;PING&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;PONG&quot;);&#10;    } else {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT unknown_command&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/commands.h&quot;&#10;#include &quot;../include/network.h&quot;&#10;#include &quot;../include/room.h&quot;&#10;#include &quot;../include/client.h&quot;&#10;#include &lt;string.h&gt;&#10;#include &lt;pthread.h&gt;&#10;&#10;extern pthread_mutex_t global_lock;&#10;&#10;void handle_hello(client_t *c, char *args) {&#10;    char *nick = strtok(args, &quot; &quot;);&#10;    if (!nick) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_nick&quot;);&#10;        return;&#10;    }&#10;    strncpy(c-&gt;nick, nick, NICK_MAX);&#10;    c-&gt;nick[NICK_MAX] = '\0';&#10;    gen_token(c-&gt;token);&#10;    c-&gt;state = ST_AUTH;&#10;    send_line(c-&gt;fd, &quot;WELCOME %s&quot;, c-&gt;token);&#10;}&#10;&#10;void handle_list(client_t *c) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE not_auth&quot;);&#10;        return;&#10;    }&#10;    send_room_list(c-&gt;fd);&#10;}&#10;&#10;void handle_create(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *rname = strtok(args, &quot; &quot;);&#10;    if (!rname) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_name&quot;);&#10;        return;&#10;    }&#10;    int rid = create_room(rname);&#10;    if (rid &lt; 0) {&#10;        send_line(c-&gt;fd, &quot;ERR 200 SERVER_FULL&quot;);&#10;        return;&#10;    }&#10;    char buf[LINE_BUF];&#10;    snprintf(buf, LINE_BUF, &quot;ROOM_CREATED %d&quot;, rid);&#10;    send_broadcast(buf);&#10;}&#10;&#10;void handle_join(client_t *c, char *args) {&#10;    if (c-&gt;state != ST_AUTH) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE&quot;);&#10;        return;&#10;    }&#10;    char *idstr = strtok(args, &quot; &quot;);&#10;    if (!idstr) {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT missing_room_id&quot;);&#10;        return;&#10;    }&#10;    int rid = atoi(idstr);&#10;&#10;    room_t *r = find_room_by_id(rid);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 106 ROOM_WRONG_STATE&quot;);&#10;        return;&#10;    }&#10;&#10;    add_player_to_room(c, r);&#10;&#10;    if (r-&gt;player_count == 2) {&#10;        client_t *other = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;        send_line(other-&gt;fd, &quot;PLAYER_JOINED %s&quot;, c-&gt;nick);&#10;    }&#10;}&#10;&#10;void handle_ready(client_t *c) {&#10;    c-&gt;state = ST_READY;&#10;    send_line(c-&gt;fd, &quot;OK you_are_ready&quot;);&#10;&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r || r-&gt;player_count == 1) return;&#10;&#10;    client_t *opponent = (r-&gt;player1 == c) ? r-&gt;player2 : r-&gt;player1;&#10;&#10;    if (opponent-&gt;state == ST_READY) {&#10;        r-&gt;state = RM_PLAYING;&#10;    }&#10;    send_line(opponent-&gt;fd, &quot;PLAYER_READY %s&quot;, c-&gt;nick);&#10;}&#10;&#10;void handle_leave(client_t *c) {&#10;    room_t *r = find_room_by_id(c-&gt;room_id);&#10;    if (!r) {&#10;        send_line(c-&gt;fd, &quot;ERR 104 UNKNOWN_ROOM&quot;);&#10;        return;&#10;    }&#10;&#10;    if (r-&gt;state != RM_FULL &amp;&amp; r-&gt;state != RM_OPEN) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    if (c-&gt;state != ST_IN_LOBBY &amp;&amp; c-&gt;state != ST_READY) {&#10;        send_line(c-&gt;fd, &quot;ERR 101 INVALID_STATE cannot_leave_now&quot;);&#10;        return;&#10;    }&#10;&#10;    remove_player_from_room(c, r);&#10;    send_line(c-&gt;fd, &quot;LEFT_ROOM %d&quot;, r-&gt;id);&#10;}&#10;&#10;void handle_line(client_t *c, char *line) {&#10;    trim_crlf(line);&#10;    if (strlen(line) == 0) return;&#10;&#10;    char *cmd = strtok(line, &quot; &quot;);&#10;    if (!cmd) return;&#10;&#10;    char *args = strtok(NULL, &quot;&quot;);&#10;&#10;    if (strcmp(cmd, &quot;HELLO&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_hello(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LIST&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_list(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;CREATE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_create(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;JOIN&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_join(c, args);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;READY&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_ready(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;LEAVE&quot;) == 0) {&#10;        pthread_mutex_lock(&amp;global_lock);&#10;        handle_leave(c);&#10;        pthread_mutex_unlock(&amp;global_lock);&#10;    } else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;OK bye&quot;);&#10;    } else if (strcmp(cmd, &quot;PING&quot;) == 0) {&#10;        send_line(c-&gt;fd, &quot;PONG&quot;);&#10;    } else {&#10;        send_line(c-&gt;fd, &quot;ERR 100 BAD_FORMAT unknown_command&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>